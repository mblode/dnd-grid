{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "kitchen-sink-example",
  "type": "registry:component",
  "title": "Kitchen sink",
  "description": "A full-featured builder with external drag, selection, action bar, and edit panel.",
  "dependencies": [
    "@dnd-grid/react",
    "react-draggable",
    "react-resizable",
    "@dnd-kit/core"
  ],
  "css": {
    "@import \"@dnd-grid/react/styles.css\"": {}
  },
  "files": [
    {
      "path": "examples/dnd-grid-kitchen-sink-example.tsx",
      "type": "registry:component",
      "content": "\"use client\";\n\nimport {\n  DndGrid,\n  type DndGrid as DndGridHandle,\n  type Layout,\n  type LayoutItem,\n} from \"@dnd-grid/react\";\nimport {\n  DndContext,\n  type DragEndEvent,\n  type DragMoveEvent,\n  DragOverlay,\n  type DragStartEvent,\n  KeyboardSensor,\n  MouseSensor,\n  TouchSensor,\n  useDraggable,\n  useSensor,\n  useSensors,\n} from \"@dnd-kit/core\";\nimport { useCallback, useMemo, useRef, useState } from \"react\";\n\ntype PaletteItem = {\n  id: string;\n  title: string;\n  w: number;\n  h: number;\n};\n\ntype GridItem = {\n  id: string;\n  title: string;\n  w: number;\n  h: number;\n  x: number;\n  y: number;\n};\n\nconst paletteItems: PaletteItem[] = [\n  { id: \"text\", title: \"Text\", w: 4, h: 4 },\n  { id: \"media\", title: \"Media\", w: 4, h: 3 },\n  { id: \"cta\", title: \"CTA\", w: 2, h: 2 },\n  { id: \"quote\", title: \"Quote\", w: 3, h: 3 },\n];\n\nconst initialItems: GridItem[] = [\n  { id: \"a\", title: \"Text\", x: 0, y: 0, w: 4, h: 4 },\n  { id: \"b\", title: \"Media\", x: 0, y: 4, w: 2, h: 3 },\n  { id: \"c\", title: \"CTA\", x: 2, y: 4, w: 2, h: 2 },\n  { id: \"d\", title: \"Quote\", x: 0, y: 7, w: 4, h: 3 },\n];\n\nconst findEmptyPosition = ({\n  layouts,\n  newItemWidth,\n  newItemHeight,\n  gridWidth,\n  gridHeight,\n}: {\n  layouts: Layout;\n  newItemWidth: number;\n  newItemHeight: number;\n  gridWidth: number;\n  gridHeight: number;\n}): { x: number; y: number } => {\n  const grid = Array.from({ length: gridHeight }, () =>\n    Array.from({ length: gridWidth }, () => false),\n  );\n\n  layouts.forEach((item) => {\n    for (let x = item.x; x < item.x + item.w; x += 1) {\n      for (let y = item.y; y < item.y + item.h; y += 1) {\n        if (grid[y] && grid[y][x] !== undefined) {\n          grid[y][x] = true;\n        }\n      }\n    }\n  });\n\n  for (let y = 0; y <= gridHeight - newItemHeight; y += 1) {\n    for (let x = 0; x <= gridWidth - newItemWidth; x += 1) {\n      let hasSpace = true;\n\n      for (let dx = 0; dx < newItemWidth; dx += 1) {\n        for (let dy = 0; dy < newItemHeight; dy += 1) {\n          if (grid[y + dy][x + dx]) {\n            hasSpace = false;\n            break;\n          }\n        }\n        if (!hasSpace) break;\n      }\n\n      if (hasSpace) {\n        return { x, y };\n      }\n    }\n  }\n\n  return { x: 0, y: Infinity };\n};\n\nconst getSm = ({\n  layouts,\n  selectedBlockId,\n  currentBlock,\n}: {\n  layouts: Layout;\n  selectedBlockId?: string | null;\n  currentBlock?: { w: number; h: number };\n}) => {\n  const foundItem = selectedBlockId\n    ? layouts.find((item) => item.id === selectedBlockId)\n    : undefined;\n\n  if (foundItem && currentBlock) {\n    const beneathPositionY = foundItem.y + foundItem.h - 1;\n\n    return {\n      x: foundItem.x,\n      y: beneathPositionY,\n      w: currentBlock.w || 1,\n      h: currentBlock.h || 1,\n    };\n  }\n\n  if (foundItem) {\n    const beneathPositionY = foundItem.y + foundItem.h - 1;\n\n    return {\n      x: foundItem.x,\n      y: beneathPositionY,\n      w: foundItem.w,\n      h: foundItem.h,\n    };\n  }\n\n  if (currentBlock) {\n    const position = findEmptyPosition({\n      layouts,\n      newItemHeight: currentBlock.h || 1,\n      newItemWidth: currentBlock.w || 1,\n      gridWidth: 4,\n      gridHeight: 1000,\n    });\n\n    return {\n      x: position.x,\n      y: position.y,\n      w: currentBlock.w || 1,\n      h: currentBlock.h || 1,\n    };\n  }\n\n  return undefined;\n};\n\nconst collides = (a: LayoutItem, b: LayoutItem) =>\n  a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;\n\nconst resolveDropLayout = ({\n  layout,\n  dropItem,\n}: {\n  layout: Layout;\n  dropItem: LayoutItem;\n}): Layout => {\n  const placed: LayoutItem[] = [{ ...dropItem }];\n  const next: LayoutItem[] = [{ ...dropItem }];\n  const sorted = layout\n    .filter((item) => item.id !== dropItem.id)\n    .map((item) => ({ ...item }))\n    .sort((a, b) => (a.y === b.y ? a.x - b.x : a.y - b.y));\n\n  for (const item of sorted) {\n    let candidate = { ...item };\n    let needsPlacement = true;\n\n    while (needsPlacement) {\n      needsPlacement = false;\n      let nextY = candidate.y;\n\n      for (const placedItem of placed) {\n        if (collides(candidate, placedItem)) {\n          nextY = Math.max(nextY, placedItem.y + placedItem.h);\n          needsPlacement = true;\n        }\n      }\n\n      if (needsPlacement) {\n        candidate = { ...candidate, y: nextY };\n      }\n    }\n\n    placed.push(candidate);\n    next.push(candidate);\n  }\n\n  return next;\n};\n\nconst getPointerCoordinates = (event?: Event | null) => {\n  if (!event) return null;\n  if (\"touches\" in event) {\n    const touchEvent = event as TouchEvent;\n    const touch = touchEvent.touches[0] ?? touchEvent.changedTouches[0];\n    if (touch) {\n      return { x: touch.clientX, y: touch.clientY };\n    }\n  }\n  if (\"clientX\" in event && \"clientY\" in event) {\n    const mouseEvent = event as MouseEvent;\n    return { x: mouseEvent.clientX, y: mouseEvent.clientY };\n  }\n  return null;\n};\n\ntype PaletteDraggableProps = {\n  item: PaletteItem;\n  isActive: boolean;\n  onClick?: (item: PaletteItem) => void;\n};\n\nconst PaletteDraggable = ({\n  item,\n  isActive,\n  onClick,\n}: PaletteDraggableProps) => {\n  const { attributes, listeners, setNodeRef, isDragging } = useDraggable({\n    id: item.id,\n    data: {\n      palette: item,\n    },\n  });\n\n  return (\n    <button\n      ref={setNodeRef}\n      type=\"button\"\n      {...listeners}\n      {...attributes}\n      onClick={() => {\n        if (isDragging) return;\n        onClick?.(item);\n      }}\n      style={{\n        border: `1px solid ${isActive || isDragging ? \"#0f172a\" : \"#e5e7eb\"}`,\n        borderRadius: 8,\n        padding: \"8px 12px\",\n        textAlign: \"left\",\n        fontSize: 12,\n        cursor: \"grab\",\n        background: \"#fff\",\n        opacity: isDragging ? 0.4 : 1,\n      }}\n    >\n      <div style={{ fontWeight: 600 }}>{item.title}</div>\n    </button>\n  );\n};\n\nexport function KitchenSinkExample() {\n  const [items, setItems] = useState<GridItem[]>(initialItems);\n  const [selectedId, setSelectedId] = useState<string | null>(null);\n  const [hoveredId, setHoveredId] = useState<string | null>(null);\n  const [isEditing, setIsEditing] = useState(false);\n  const [activePaletteId, setActivePaletteId] = useState<string | null>(null);\n  const gridApiRef = useRef<DndGridHandle | null>(null);\n  const dragItemRef = useRef<PaletteItem | null>(null);\n  const dragPointerOffsetRef = useRef<{ x: number; y: number } | null>(null);\n  const isOverGridRef = useRef(false);\n  const gridRef = useRef<HTMLDivElement | null>(null);\n  const nextIdRef = useRef(1);\n\n  const sensors = useSensors(\n    useSensor(MouseSensor, { activationConstraint: { distance: 10 } }),\n    useSensor(TouchSensor, {\n      activationConstraint: { delay: 250, tolerance: 10 },\n    }),\n    useSensor(KeyboardSensor),\n  );\n\n  const layout = useMemo<Layout>(\n    () =>\n      items.map(({ id, x, y, w, h }) => ({\n        id,\n        x,\n        y,\n        w,\n        h,\n      })),\n    [items],\n  );\n\n  const activePaletteItem = useMemo(\n    () => paletteItems.find((item) => item.id === activePaletteId) ?? null,\n    [activePaletteId],\n  );\n\n  const selectItem = useCallback((id: string | null) => {\n    setSelectedId(id);\n    setHoveredId(id);\n    setIsEditing(Boolean(id));\n  }, []);\n\n  const resetDndState = useCallback((clearDragItem = true) => {\n    setActivePaletteId(null);\n    if (clearDragItem) {\n      dragItemRef.current = null;\n    }\n    dragPointerOffsetRef.current = null;\n    isOverGridRef.current = false;\n  }, []);\n\n  const handleLayoutChange = (nextLayout: Layout) => {\n    setItems((prev) =>\n      prev.map((item) => {\n        const next = nextLayout.find((layoutItem) => layoutItem.id === item.id);\n        return next ? { ...item, ...next } : item;\n      }),\n    );\n  };\n\n  const handleDelete = (id: string) => {\n    setItems((prev) => prev.filter((item) => item.id !== id));\n    if (selectedId === id) {\n      selectItem(null);\n    }\n  };\n\n  const handleDuplicate = (id: string) => {\n    const source = items.find((item) => item.id === id);\n    if (!source) return;\n    const sm = getSm({ layouts: layout, selectedBlockId: id });\n    if (!sm) return;\n    const nextId = `k${nextIdRef.current}`;\n    nextIdRef.current += 1;\n    setItems((prev) => [\n      ...prev,\n      {\n        ...source,\n        id: nextId,\n        x: sm.x,\n        y: sm.y,\n        w: sm.w,\n        h: sm.h,\n      },\n    ]);\n    selectItem(nextId);\n  };\n\n  const handlePaletteClick = (item: PaletteItem) => {\n    const sm = getSm({\n      layouts: layout,\n      currentBlock: { w: item.w, h: item.h },\n    });\n    if (!sm) return;\n    const nextId = `k${nextIdRef.current}`;\n    nextIdRef.current += 1;\n    setItems((prev) => [\n      ...prev,\n      {\n        id: nextId,\n        title: item.title,\n        w: sm.w,\n        h: sm.h,\n        x: sm.x,\n        y: sm.y,\n      },\n    ]);\n    selectItem(nextId);\n  };\n\n  const handleDropDragOver = () => {\n    const active = dragItemRef.current;\n    return active ? { w: active.w, h: active.h } : undefined;\n  };\n\n  const handleDrop = (_layout: Layout, item?: LayoutItem | null) => {\n    const active = dragItemRef.current;\n    if (!active || !item) return;\n    const nextId = `k${nextIdRef.current}`;\n    nextIdRef.current += 1;\n    setItems((prev) => {\n      const prevLayout = prev.map(({ id, x, y, w, h }) => ({\n        id,\n        x,\n        y,\n        w,\n        h,\n      }));\n      const dropItem: LayoutItem = {\n        id: nextId,\n        x: item.x,\n        y: item.y,\n        w: item.w,\n        h: item.h,\n      };\n      const nextLayout = resolveDropLayout({\n        layout: prevLayout,\n        dropItem,\n      });\n      const layoutById = new Map(nextLayout.map((entry) => [entry.id, entry]));\n      const nextItems = prev.map((entry) => {\n        const next = layoutById.get(entry.id);\n        return next ? { ...entry, ...next } : entry;\n      });\n      const dropLayout = layoutById.get(nextId);\n      if (dropLayout) {\n        nextItems.push({\n          id: nextId,\n          title: active.title,\n          w: dropLayout.w,\n          h: dropLayout.h,\n          x: dropLayout.x,\n          y: dropLayout.y,\n        });\n      }\n      return nextItems;\n    });\n    dragItemRef.current = null;\n    setActivePaletteId(null);\n    selectItem(nextId);\n  };\n\n  const handleDndDragStart = useCallback((event: DragStartEvent) => {\n    const active = event.active.data.current?.palette as\n      | PaletteItem\n      | undefined;\n    if (!active) return;\n    dragItemRef.current = active;\n    setActivePaletteId(active.id);\n    const initial = event.active.rect.current.initial;\n    const point = getPointerCoordinates(event.activatorEvent ?? null);\n    if (initial && point) {\n      dragPointerOffsetRef.current = {\n        x: point.x - initial.left,\n        y: point.y - initial.top,\n      };\n    } else {\n      dragPointerOffsetRef.current = null;\n    }\n  }, []);\n\n  const handleDndDragMove = useCallback((event: DragMoveEvent) => {\n    const translated = event.active.rect.current.translated;\n    if (!translated) return;\n\n    const gridRect = gridRef.current?.getBoundingClientRect();\n    if (!gridRect) {\n      isOverGridRef.current = false;\n      gridApiRef.current?.handleDndRect();\n      return;\n    }\n\n    const offset = dragPointerOffsetRef.current;\n    const pointerX = offset\n      ? translated.left + offset.x\n      : translated.left + translated.width / 2;\n    const pointerY = offset\n      ? translated.top + offset.y\n      : translated.top + translated.height / 2;\n    const isOverGrid =\n      pointerX >= gridRect.left &&\n      pointerX <= gridRect.right &&\n      pointerY >= gridRect.top &&\n      pointerY <= gridRect.bottom;\n\n    isOverGridRef.current = isOverGrid;\n\n    if (!isOverGrid) {\n      gridApiRef.current?.handleDndRect();\n      return;\n    }\n\n    gridApiRef.current?.handleDndRect(\n      event.activatorEvent ?? new Event(\"dragover\"),\n      {\n        top: pointerY,\n        right: pointerX,\n        bottom: pointerY,\n        left: pointerX,\n        width: 0,\n        height: 0,\n      },\n    );\n  }, []);\n\n  const handleDndDragEnd = useCallback(\n    (event: DragEndEvent) => {\n      const shouldDrop = isOverGridRef.current;\n      resetDndState(!shouldDrop);\n\n      if (shouldDrop) {\n        gridApiRef.current?.handleDndRect(\n          event.activatorEvent ?? new Event(\"drop\"),\n        );\n        return;\n      }\n\n      gridApiRef.current?.handleDndRect();\n    },\n    [resetDndState],\n  );\n\n  const handleDndDragCancel = useCallback(() => {\n    resetDndState();\n    gridApiRef.current?.handleDndRect();\n  }, [resetDndState]);\n\n  const selectedItem = items.find((item) => item.id === selectedId) ?? null;\n  const isAddPanel = !isEditing;\n  const isEditPanel = isEditing;\n\n  return (\n    <DndContext\n      sensors={sensors}\n      onDragStart={handleDndDragStart}\n      onDragMove={handleDndDragMove}\n      onDragEnd={handleDndDragEnd}\n      onDragCancel={handleDndDragCancel}\n    >\n      <div\n        style={{\n          display: \"grid\",\n          gap: 16,\n          gridTemplateColumns: \"minmax(0, 1fr) 240px\",\n        }}\n      >\n        <div ref={gridRef}>\n          <DndGrid\n            ref={gridApiRef}\n            layout={layout}\n            cols={4}\n            rowHeight={40}\n            resizeHandles={[\"ne\", \"nw\", \"se\", \"sw\"]}\n            onDrop={handleDrop}\n            onDropDragOver={handleDropDragOver}\n            onLayoutChange={handleLayoutChange}\n            dragCancel=\".kitchen-sink-action\"\n          >\n            {items.map((item) => {\n              const isSelected = selectedId === item.id;\n              const isHovered = hoveredId === item.id;\n\n              return (\n                <div\n                  key={item.id}\n                  style={{\n                    height: \"100%\",\n                    position: \"relative\",\n                    zIndex: isHovered ? 120 : \"auto\",\n                  }}\n                >\n                  <button\n                    type=\"button\"\n                    onMouseEnter={() => setHoveredId(item.id)}\n                    onFocus={() => setHoveredId(item.id)}\n                    onMouseDown={() => selectItem(item.id)}\n                    onClick={() => selectItem(item.id)}\n                    style={{\n                      appearance: \"none\",\n                      width: \"100%\",\n                      height: \"100%\",\n                      textAlign: \"left\",\n                      border: isSelected\n                        ? \"2px solid #0f9d78\"\n                        : \"1px solid #e5e7eb\",\n                      borderRadius: 8,\n                      padding: 10,\n                      fontSize: 12,\n                      background: \"#fff\",\n                      boxShadow: isHovered\n                        ? \"0 6px 18px rgba(15, 23, 42, 0.08)\"\n                        : \"none\",\n                      cursor: \"grab\",\n                    }}\n                  >\n                    <div style={{ fontWeight: 600 }}>{item.title}</div>\n                  </button>\n                  {isHovered && (\n                    <div\n                      className=\"kitchen-sink-action\"\n                      style={{\n                        position: \"absolute\",\n                        bottom: -34,\n                        left: \"50%\",\n                        transform: \"translateX(-50%)\",\n                        display: \"flex\",\n                        gap: 6,\n                        border: \"1px solid #e5e7eb\",\n                        borderRadius: 6,\n                        padding: \"4px 8px\",\n                        background: \"#fff\",\n                        fontSize: 10,\n                        zIndex: 130,\n                      }}\n                    >\n                      <button type=\"button\" onClick={() => selectItem(item.id)}>\n                        Edit\n                      </button>\n                      <button\n                        type=\"button\"\n                        onClick={() => handleDuplicate(item.id)}\n                      >\n                        Duplicate\n                      </button>\n                      <button\n                        type=\"button\"\n                        onClick={() => handleDelete(item.id)}\n                      >\n                        Delete\n                      </button>\n                    </div>\n                  )}\n                </div>\n              );\n            })}\n          </DndGrid>\n        </div>\n\n        <div\n          style={{\n            border: \"1px solid #e5e7eb\",\n            borderRadius: 8,\n            padding: 12,\n            fontSize: 12,\n          }}\n        >\n          <div\n            style={{\n              display: \"flex\",\n              justifyContent: \"space-between\",\n              gap: 8,\n              marginBottom: 8,\n              alignItems: \"center\",\n            }}\n          >\n            <div style={{ display: \"flex\", gap: 8, alignItems: \"center\" }}>\n              {isEditPanel && (\n                <button\n                  type=\"button\"\n                  onClick={() => setIsEditing(false)}\n                  style={{\n                    borderRadius: 999,\n                    padding: \"4px 10px\",\n                    fontSize: 10,\n                    border: \"1px solid #e5e7eb\",\n                    background: \"#fff\",\n                  }}\n                >\n                  Back\n                </button>\n              )}\n              <div style={{ fontWeight: 600 }}>\n                {isEditPanel ? \"Edit block\" : \"Add block\"}\n              </div>\n            </div>\n          </div>\n\n          {isAddPanel ? (\n            <div style={{ display: \"grid\", gap: 8 }}>\n              {paletteItems.map((item) => (\n                <PaletteDraggable\n                  key={item.id}\n                  item={item}\n                  isActive={activePaletteId === item.id}\n                  onClick={handlePaletteClick}\n                />\n              ))}\n            </div>\n          ) : (\n            selectedItem && (\n              <label style={{ display: \"grid\", gap: 4 }}>\n                <div style={{ fontSize: 10, color: \"#6b7280\" }}>Title</div>\n                <input\n                  value={selectedItem.title}\n                  onChange={(event) =>\n                    setItems((prev) =>\n                      prev.map((item) =>\n                        item.id === selectedItem.id\n                          ? { ...item, title: event.target.value }\n                          : item,\n                      ),\n                    )\n                  }\n                  style={{\n                    height: 40,\n                    width: \"100%\",\n                    borderRadius: 16,\n                    border: \"1px solid #e5e7eb\",\n                    background: \"#fff\",\n                    padding: \"0 12px\",\n                    fontSize: 14,\n                    boxShadow: \"0 1px 2px rgba(15, 23, 42, 0.08)\",\n                  }}\n                />\n              </label>\n            )\n          )}\n        </div>\n      </div>\n\n      <DragOverlay>\n        {activePaletteItem ? (\n          <div\n            style={{\n              border: \"1px solid #0f172a\",\n              borderRadius: 8,\n              padding: \"8px 12px\",\n              textAlign: \"left\",\n              fontSize: 12,\n              cursor: \"grabbing\",\n              background: \"#fff\",\n              width: 200,\n              boxShadow: \"0 8px 24px rgba(15, 23, 42, 0.15)\",\n            }}\n          >\n            <div style={{ fontWeight: 600 }}>{activePaletteItem.title}</div>\n          </div>\n        ) : null}\n      </DragOverlay>\n    </DndContext>\n  );\n}\n"
    }
  ]
}
